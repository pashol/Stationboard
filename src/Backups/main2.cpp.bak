#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <SPI.h>
#include "TFT_eSPI.h"
#include <WiFiUDP.h>
#include <NTPClient.h>
#include <FS.h>
#include <JsonStreamingParser.h>
#include <JsonListener.h>

// Display-Konfiguration
#define AA_FONT_SMALL "NotoSansBold15"
#define AA_FONT_LARGE "NotoSansBold36"
#define STATION "8577582"
#define LIMIT 4

// Layout-Konstanten
#define POS_TIME 3
#define POS_BUS  50
#define POS_TO   100
#define POS_INC  18
#define POS_FIRST 30
int newLine = POS_FIRST;

// WiFi-Konfiguration
const char* ssid = "Fortuna";
const char* password = "Allrueti136343Rotkreuz";
String base_url = "http://transport.opendata.ch/v1/stationboard?id=";
String url_limit = "&limit=";

// Globale Objekte
TFT_eSPI tft = TFT_eSPI();
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP);

// Parser Status
String currentKey;
bool inStationboard = false;
bool inStop = false;
bool inPrognosis = false;
int entryCount = 0;

// Aktueller Eintrag
String currentDeparture;
String currentPrognosisDeparture;
String currentNumber;
String currentCategory;
String currentTo;

// Hilfsfunktion: Zeit formatieren (HH:MM)
String formatTime(const String& timestamp) {
    if (timestamp.length() >= 16) {
        return timestamp.substring(11, 16);
    }
    return "??:??";
}

// Hilfsfunktion: Versp채tung berechnen
int calculateDelay(const String& scheduled, const String& prognosis) {
    if (scheduled.isEmpty() || prognosis.isEmpty()) return 0;
    
    int schHour = scheduled.substring(11, 13).toInt();
    int schMin = scheduled.substring(14, 16).toInt();
    int progHour = prognosis.substring(11, 13).toInt();
    int progMin = prognosis.substring(14, 16).toInt();
    
    int scheduledMinutes = schHour * 60 + schMin;
    int prognosisMinutes = progHour * 60 + progMin;
    
    if (prognosisMinutes < scheduledMinutes - 720) {
        prognosisMinutes += 24 * 60;
    }
    
    return prognosisMinutes - scheduledMinutes;
}

// Display Header zeichnen
void drawHeader() {
    tft.loadFont(AA_FONT_SMALL);
    tft.fillScreen(TFT_BLUE);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
    tft.fillRect(0, 0, tft.width(), 25, TFT_WHITE);
    tft.setCursor(POS_BUS, 7);
    tft.print("Bus");
    tft.setCursor(POS_TO, 7);
    tft.print("Nach");
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
}

// Aktuellen Eintrag anzeigen
void displayEntry() {
    if (!currentDeparture.isEmpty()) {
        String timeStr = formatTime(currentDeparture);
        int delay = calculateDelay(currentDeparture, 
                                 currentPrognosisDeparture.isEmpty() ? 
                                 currentDeparture : currentPrognosisDeparture);
        
        // Zeit anzeigen
        tft.setCursor(POS_TIME, newLine);
        tft.print(timeStr);
        if (delay > 0) {
            tft.printf(" +%d", delay);
        }
        
        // Bus und Ziel anzeigen
        tft.setCursor(POS_BUS, newLine);
        tft.printf("%-1s%-3s", 
                     currentCategory.c_str(),
                     currentNumber.c_str());
        tft.setCursor(POS_TO, newLine);
        tft.printf("%-20s", currentTo.c_str());
        
        newLine += POS_INC;
        
        Serial.printf("Bus %s%s nach %s: %s (Versp채tung: %d min)\n",
                    currentCategory.c_str(),
                    currentNumber.c_str(),
                    currentTo.c_str(),
                    timeStr.c_str(),
                    delay);
    }
}

// Parser Ereignis-Handler
class SimpleListener: public JsonListener {
    public:
        void whitespace(char c) override {}
        
        void startDocument() override {
            Serial.println("Start JSON");
            entryCount = 0;
            newLine = POS_FIRST;
            drawHeader();
        }
        
        void endDocument() override {
            Serial.println("Ende JSON");
        }
        
        void startObject() override {
            if (currentKey == "stop") {
                inStop = true;
            } else if (currentKey == "prognosis") {
                inPrognosis = true;
            }
        }
        
        void endObject() override {
            if (inStop && !inPrognosis) {
                inStop = false;
            } else if (inPrognosis) {
                inPrognosis = false;
            } else if (inStationboard) {
                displayEntry();
                // Reset current entry
                currentDeparture = "";
                currentPrognosisDeparture = "";
                currentNumber = "";
                currentCategory = "";
                currentTo = "";
                entryCount++;
            }
        }
        
        void startArray() override {
            if (currentKey == "stationboard") {
                inStationboard = true;
            }
        }
        
        void endArray() override {
            if (currentKey == "stationboard") {
                inStationboard = false;
            }
        }
        
        void key(String key) override {
            currentKey = key;
        }
        
        void value(String value) override {
            if (!inStationboard || entryCount >= LIMIT) return;

            if (inStop) {
                if (inPrognosis) {
                    if (currentKey == "departure") {
                        currentPrognosisDeparture = value;
                    }
                } else if (currentKey == "departure") {
                    currentDeparture = value;
                }
            } else if (currentKey == "number") {
                currentNumber = value;
            } else if (currentKey == "category") {
                currentCategory = value;
            } else if (currentKey == "to") {
                currentTo = value;
            }
        }
};

void setup() {
    Serial.begin(115200);
    
    // Display initialisieren
    tft.begin();
    tft.setRotation(1);
    tft.fillScreen(TFT_BLACK);

    
    // WiFi Verbindung
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Verbinde mit WiFi...");
    }
    
    // Zeit-Client
    timeClient.begin();
    timeClient.setTimeOffset(3600);
    
    // SPIFFS und Fonts pr체fen
    if (!SPIFFS.begin()) {
        Serial.println("SPIFFS Fehler!");
        while(1) yield();
    }
    
    if (!SPIFFS.exists("/NotoSansBold15.vlw") || 
        !SPIFFS.exists("/NotoSansBold36.vlw")) {
        Serial.println("Fonts fehlen!");
        while(1) yield();
    }
}

void loop() {
    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        String url = base_url + STATION + url_limit + LIMIT;
        http.begin(url);
        
        int httpCode = http.GET();
        if (httpCode == HTTP_CODE_OK) {
            Serial.print("Free Heap before parsing: ");
            Serial.println(ESP.getFreeHeap());
            
            JsonStreamingParser parser;
            SimpleListener listener;
            parser.setListener(&listener);
            
            WiFiClient& stream = http.getStream();
            
            // Stream verarbeiten
            while (http.connected() && (stream.available() > 0 || stream.connected())) {
                size_t size = stream.available();
                if (size > 0) {
                    int c = stream.read();
                    parser.parse(c);
                }
                yield();  // WDT f체ttern
            }
            
            Serial.print("Free Heap after parsing: ");
            Serial.println(ESP.getFreeHeap());
            
            // Aktuelle Zeit anzeigen
            timeClient.update();
            tft.loadFont(AA_FONT_SMALL);
            tft.setTextColor(TFT_BLACK, TFT_WHITE);
            tft.fillRect(0, tft.height() - 25, tft.width(), 25, TFT_WHITE);
            tft.setCursor(4, tft.height() - 20);
            tft.print("Zeit: ");
            tft.print(timeClient.getFormattedTime());
            
        }
        
        http.end();
    }
    
    delay(60000);
}