#include <Arduino.h>
#include <ArduinoJson.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <SPI.h>
#include "TFT_eSPI.h"
#include <WiFiUdp.h>
#include <NTPClient.h>
#include <FS.h>
#include <JsonListener.h>
#include <JsonStreamingParser.h>
#include <WiFiManager.h>          //https://github.com/tzapu/WiFiManager WiFi Configuration Magic
#include <SPIFFS.h>
#include <NotoSansBold15.h>

using fs::File;

// Config parameters from the WIFIManager Setup
struct Config {
    String stationId = "8577582";  // Default values
    int limit = 8;
};

#define getBTCAPI "https://api.coinbase.com/v2/prices/BTC-USD/spot"
#define AA_FONT_SMALL "NotoSansBold15"
#define AA_FONT_LARGE "NotoSansBold36"
#define POS_TIME 3
#define POS_DELAY 47
#define POS_BUS  80
#define POS_TO   130
#define POS_INC  18
#define POS_FIRST 30
int newLine = POS_FIRST;
int bitcoin_price = 0;
bool shouldSaveConfig = false;

String base_url = "http://transport.opendata.ch/v1/stationboard?id=";
String url_limit = "&limit=";
String url = "http://transport.opendata.ch/v1/stationboard?id=8577582&limit=2"; //Fallback

const unsigned long UPDATE_INTERVAL = 60000; // Update every 60 seconds
// Define days of the week and months arrays
const char* DAYS[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
const char* MONTHS[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
const long timeOffset = 3600; // UTC+1
unsigned long lastUpdate = 0;

// Create WiFiManager object
WiFiManager wm;

TFT_eSPI tft = TFT_eSPI();
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", timeOffset);
Config config;

class TransportListener: public JsonListener {
private:
    String currentKey;
    String currentPath;
    String station;
    int arrayIndex = 0;
    bool inStationboard = false;
    bool inStop = false;
    int displayedTransports = 0;
    TFT_eSPI& display;
    // Add sprite as class member
    TFT_eSprite* lineSprite = nullptr;
    
    struct {
        String name;
        String number;
        String operatorName;
        String destination;
        String departure;
        String delay;
        String category;
    } currentTransport;

    void resetTransport() {
        currentTransport.name = "";
        currentTransport.number = "";
        currentTransport.operatorName = "";
        currentTransport.destination = "";
        currentTransport.departure = "";
        currentTransport.delay = "";
        currentTransport.category = "";
    }

    String extractTime(const String& isoTime) {
        if (isoTime.length() >= 16) {
            return isoTime.substring(11, 16); // Extract HH:MM
        }
        return "";
    }

public:
    TransportListener(TFT_eSPI& tft) : display(tft) {}
    
    virtual void whitespace(char c) {
        // Ignore whitespace characters
    }

    void startDocument() {   
        display.fillRect(0,25,display.width(), display.height() - 50, TFT_BLUE);

        // Draw header line
        Serial.println("Start parsing");
        displayedTransports = 0;
        inStationboard = false;
        currentPath = "";
        currentKey = "";
        inStop = false;
    }

    void key(String key) {
        currentKey = key;
        
        // Update the path based on where we are
        if (inStationboard) {
            if (inStop) {
                currentPath = "stationboard/stop/" + key;
            } else {
                currentPath = "stationboard/" + key;
            }
        }
        
        //Serial.print("Current path: ");
        //Serial.println(currentPath);
    }

    void value(String value) {
        String fullPath = currentPath + "/" + currentKey;
        // Serial.print("Value at path ");
        // Serial.print(fullPath);
        // Serial.print(": ");
        // Serial.println(value);

        if (station.isEmpty()){
            if (fullPath == "/station/name") {
                station = value;
                Serial.print("Found station: ");
                Serial.println(value);
                drawStation();
            }
        }

        // Process only the paths we need
        if (fullPath.endsWith("/stop/departure")) {
            currentTransport.departure = extractTime(value);
            Serial.print("Found departure: ");
            Serial.println(extractTime(value));
        }
        else if (fullPath.endsWith("/stop/delay")) {
            currentTransport.delay = value;
            Serial.print("Found delay: ");
            Serial.println(value);
        }
        else if (fullPath.endsWith("/stationboard/name")) {
            Serial.print("Found name: ");
            Serial.println(value);
            currentTransport.category = value;
        }
        else if (fullPath.endsWith("/category")) {
            Serial.print("Found category: ");
            Serial.println(value);
            currentTransport.category = value;
        }
        else if (fullPath.endsWith("/number")) {
            Serial.print("Found number: ");
            Serial.println(value);
            currentTransport.number = value;
        }
        else if (fullPath.endsWith("/to")) {
            Serial.print("Found to: ");
            Serial.println(value);
            currentTransport.destination = value;
            displayTransport();
            resetTransport();
        }
    }

    void endArray() {
        // Remove the last path segment
        int lastSlash = currentPath.lastIndexOf('/');
        if (lastSlash >= 0) {
            currentPath = currentPath.substring(0, lastSlash);
        }
        
        // Serial.print("End array, new path: ");
        // Serial.println(currentPath);
    }

    void startArray() {
        if (currentKey.length() > 0) {
            currentPath += "/" + currentKey;
            arrayIndex = 0;
        }
        // Serial.print("Start array at path: ");
        // Serial.println(currentPath);
    }

    void startObject() {
        if (currentKey.length() > 0) {
            currentPath += "/" + currentKey;
        }
        // Serial.print("Start object at path: ");
        // Serial.println(currentPath);
    }

    void endObject() {
        // Remove the last path segment
        int lastSlash = currentPath.lastIndexOf('/');
        if (lastSlash >= 0) {
            currentPath = currentPath.substring(0, lastSlash);
        }
        
        // Serial.print("End object, new path: ");
        // Serial.println(currentPath);
    }

    void endDocument() {
        Serial.println("Ende JSON");

    }

private:
    void displayTransport() {
        if (currentTransport.number.length() > 0) {
            int yPos = POS_FIRST + (POS_INC * displayedTransports);
            
            // Create sprite if not exists
            if (lineSprite == nullptr) {
                lineSprite = new TFT_eSprite(&display);
                lineSprite->createSprite(display.width(), POS_INC);
                lineSprite->loadFont(AA_FONT_SMALL);
            }
            
            // Fill sprite background
            lineSprite->fillSprite(TFT_BLUE);
            
            // Time
            lineSprite->setTextColor(TFT_WHITE, TFT_BLUE);
            lineSprite->setCursor(POS_TIME, 0);
            lineSprite->drawString(currentTransport.departure, POS_TIME, 0);
            
            // Delay
            if (currentTransport.delay.toInt() > 0) {
                lineSprite->setTextColor(TFT_RED, TFT_BLUE);
                lineSprite->drawString("+" + currentTransport.delay, POS_DELAY, 0);
            }
            
            // Bus/Transport number
            lineSprite->setTextColor(TFT_WHITE, TFT_BLUE);
            lineSprite->setCursor(POS_BUS, 0);
            lineSprite->print(currentTransport.category + currentTransport.number);
            
            // Destination
            lineSprite->drawString(currentTransport.destination, POS_TO, 0);
            
            // Push sprite to display
            lineSprite->pushSprite(0, yPos);
            
            displayedTransports++;
        }
    }

    void drawStation() {
        tft.loadFont(AA_FONT_SMALL);
        tft.setTextColor(TFT_BLACK, TFT_WHITE);
        tft.fillRect(0, 0, tft.width(), 25, TFT_WHITE);
        tft.setCursor(POS_TIME, 7);
        tft.print(station);
    }

};

// Function to get time without seconds
String getTimeWithoutSeconds() {
    String hourStr = String(timeClient.getHours());
    if (hourStr.length() < 2) hourStr = "0" + hourStr;
    
    String minuteStr = String(timeClient.getMinutes());
    if (minuteStr.length() < 2) minuteStr = "0" + minuteStr;
    
    return hourStr + ":" + minuteStr;
}

// Function to get formatted date with time first
String getFormattedDateTime() {
    time_t epochTime = timeClient.getEpochTime();
    struct tm *ptm = gmtime ((time_t *)&epochTime);
    
    String dateTime = getTimeWithoutSeconds();
    dateTime += " - ";
    dateTime += String(ptm->tm_mday);
    dateTime += ". ";
    dateTime += MONTHS[ptm->tm_mon];

    // Add year
    dateTime += " ";
    dateTime += String(ptm->tm_year + 1900);
    
    return dateTime;
}

// Function to get day of week
String getDayOfWeek() {
    return DAYS[timeClient.getDay()];
}



void drawCurrentTime() {
    timeClient.update();
    
    // Create temporary sprite for time display
    TFT_eSprite timeSprite(&tft);
    timeSprite.createSprite(tft.width() / 2, 25);
    timeSprite.loadFont(AA_FONT_SMALL);
    
    // Clear sprite and set background
    timeSprite.fillSprite(TFT_WHITE);
    
    
    // Draw time and date
    timeSprite.setTextColor(TFT_BLACK, TFT_WHITE);
    timeSprite.drawString(getFormattedDateTime(), 4, 5);
    
    // Push to bottom of screen
    timeSprite.pushSprite(0, tft.height() - 25);
    
    // Clean up
    timeSprite.deleteSprite();
}

void drawWeather() {

    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected");
        return;
    }

    HTTPClient http;
    http.begin(getBTCAPI);
    
    int httpCode = http.GET();
    String bitcoin_price = "";
    
    if (httpCode == HTTP_CODE_OK) {
        String payload = http.getString();
        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, payload);
        
        if (doc.containsKey("data") && doc["data"].containsKey("amount")) {
            bitcoin_price = doc["data"]["amount"].as<String>().toInt();
        }
    }
    
    http.end();

    // Create temporary sprite for BTC price display
    TFT_eSprite btcSprite(&tft);
    btcSprite.createSprite((tft.width() / 2) - 25, 25);
    btcSprite.loadFont(AA_FONT_SMALL);
    
    // Clear sprite and set background
    btcSprite.fillSprite(TFT_WHITE);
    
    // Draw BTC price
    btcSprite.setTextDatum(TR_DATUM);
    btcSprite.setTextColor(TFT_BLACK, TFT_WHITE);
    btcSprite.drawString("BTC $" + bitcoin_price, btcSprite.width(), 5);
    
    // Push to bottom-right of screen
    btcSprite.pushSprite(tft.width() / 2, tft.height() - 25);
    
    Serial.print("Bitcoin Price: ");
    Serial.println(bitcoin_price);
    
    // Clean up
    btcSprite.deleteSprite();


}


void drawBTC() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected");
        return;
    }

    HTTPClient http;
    http.begin(getBTCAPI);
    
    int httpCode = http.GET();
    String bitcoin_price = "";
    
    if (httpCode == HTTP_CODE_OK) {
        String payload = http.getString();
        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, payload);
        
        if (doc.containsKey("data") && doc["data"].containsKey("amount")) {
            bitcoin_price = doc["data"]["amount"].as<String>().toInt();
        }
    }
    
    http.end();

    // Create temporary sprite for BTC price display
    TFT_eSprite btcSprite(&tft);
    btcSprite.createSprite((tft.width() / 2) - 25, 25);
    btcSprite.loadFont(AA_FONT_SMALL);
    
    // Clear sprite and set background
    btcSprite.fillSprite(TFT_WHITE);
    
    // Draw BTC price
    btcSprite.setTextDatum(TR_DATUM);
    btcSprite.setTextColor(TFT_BLACK, TFT_WHITE);
    btcSprite.drawString("BTC $" + bitcoin_price, btcSprite.width(), 5);
    
    // Push to bottom-right of screen
    btcSprite.pushSprite(tft.width() / 2, tft.height() - 25);
    
    Serial.print("Bitcoin Price: ");
    Serial.println(bitcoin_price);
    
    // Clean up
    btcSprite.deleteSprite();
}

void saveConfigCallback () {
    Serial.println("Should save config");
    shouldSaveConfig = true;
}

void loadConfiguration() {
    if (SPIFFS.exists("/config.json")) {
        File configFile = SPIFFS.open("/config.json", "r");
        if (configFile) {
            DynamicJsonDocument doc(1024);
            DeserializationError error = deserializeJson(doc, configFile);
            
            if (!error) {
                config.stationId = doc["station_id"].as<String>();
                config.limit = doc["limit"].as<int>();
            }
            configFile.close();
        }
    }
}

void saveConfiguration() {
    DynamicJsonDocument doc(1024);
    doc["station_id"] = config.stationId;
    doc["limit"] = config.limit;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
        Serial.println("Failed to open config file for writing");
        return;
    }

    serializeJson(doc, configFile);
    configFile.close();
}

void wifiInfo(){
  // can contain gargbage on esp32 if wifi is not ready yet
  Serial.println("[WIFI] WIFI_INFO DEBUG");
  WiFi.printDiag(Serial);
  Serial.println("[WIFI] MODE: " + (String)(wm.getModeString(WiFi.getMode())));
  Serial.println("[WIFI] SAVED: " + (String)(wm.getWiFiIsSaved() ? "YES" : "NO"));
  Serial.println("[WIFI] SSID: " + (String)wm.getWiFiSSID());
  Serial.println("[WIFI] PASS: " + (String)wm.getWiFiPass());
  // Serial.println("[WIFI] HOSTNAME: " + (String)WiFi.getHostname());
}


void setupWiFiManager() {
    // Initialize SPIFFS
    if (!SPIFFS.begin(true)) {
        Serial.println("Failed to mount SPIFFS");
        return;
    }

    // Load existing configuration
    loadConfiguration();

    wifiInfo();

    // Set config save notify callback
    wm.setSaveConfigCallback(saveConfigCallback);

    // Add custom parameters for transport display settings
    WiFiManagerParameter custom_station_id("station", "Station ID", config.stationId.c_str(), 40);
    WiFiManagerParameter custom_limit("limit", "Number of Entries", String(config.limit).c_str(), 5);
    
    wm.addParameter(&custom_station_id);
    wm.addParameter(&custom_limit);

    // Customize the configuration portal
    wm.setTitle("Transport Display Setup");
    
    // Enable debug output
    wm.setDebugOutput(true);
    
    // Set dark theme
    wm.setClass("invert");

    // Set configuration portal timeout (optional, in seconds)
    wm.setConfigPortalTimeout(600);

    // Start the configuration portal
    // This will:
    // 1. Create an access point named "TransportDisplay_AP"
    // 2. Start a web server at 192.168.4.1
    // 3. Provide a web interface for:
    //    - WiFi network selection
    //    - Password entry
    //    - Custom parameters (station ID and limit)
    if (!wm.autoConnect("TransportDisplay_AP")) {
        tft.drawString("To config your Stationboard:", 10, 110);
        tft.drawString("Connect to access point TransportDisplay_AP", 10, 130);
        Serial.println("Failed to connect and hit timeout");

        delay(3000);
        ESP.restart();
        delay(5000);
    } else {
        // If you get here you have connected to the WiFi
        tft.drawString("Successfully connected to WiFi network!", 20, 100);
        Serial.println("Successfully connected to WiFi network!");
    }

    
    // Read updated parameters
    config.stationId = custom_station_id.getValue();
    config.limit = String(custom_limit.getValue()).toInt();

    // Save the custom parameters to config
    if (shouldSaveConfig) {
        saveConfiguration();
    }
}


// JsonStreamingParser parser;
TransportListener* listener;

void setup() {
    Serial.begin(115200);
    
    // Initialize display
    tft.init();
    tft.setRotation(1);
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE);
    
    // URL Konstruktor
    // url = base_url + STATION + url_limit + LIMIT; //old hardcoded one
    url = base_url + config.stationId + url_limit + config.limit;
    Serial.print("URL: ");
    Serial.println(url);

    // Create listener with display reference
    listener = new TransportListener(tft);
    // parser.setListener(listener);
    
    // reset settings - wipe stored credentials for testing
    // these are stored by the esp library
    // wm.resetSettings();

    // Call WiFiManager setup
    setupWiFiManager();

    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Connecting to WiFi...");
        tft.drawString("Connecting to WiFi...", 20, 100);
    }
    
    if (!SPIFFS.begin()) {
        Serial.println("SPIFFS initialisation failed!");
        while (1) yield(); // Stay here twiddling thumbs waiting
    }
    Serial.println("\r\nSPIFFS available!");
    
    // ESP32 will crash if any of the fonts are missing
    bool font_missing = false;
    if (SPIFFS.exists("/NotoSansBold15.vlw")    == false) font_missing = true;
    if (SPIFFS.exists("/NotoSansBold36.vlw")    == false) font_missing = true;

    if (font_missing)
    {
        Serial.println("\r\nFont missing in SPIFFS, did you upload it?");
        // while(1) yield();
    }
    else Serial.println("\r\nFonts found OK.");
        
    // Initialize time client
    timeClient.begin();
    timeClient.setTimeOffset(timeOffset); // UTC+1

    // Initial Scren Setup
    tft.fillRect(0, 0 , tft.width(), 25, TFT_WHITE); //header
    tft.fillRect(0, 25, tft.width(), tft.height() - 25, TFT_BLUE); //mittelteil
    tft.fillRect(0, tft.height() - 25 , tft.width(), 25, TFT_WHITE); //footer
    tft.fillRect(tft.width() - 25, tft.height() - 25, 25, 25, TFT_WHITE); //stati   

    }

void loop() {
    
    timeClient.update();

    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin(url);
        
        int httpCode = http.GET();
        Serial.print("HTTPCODE: ");
        Serial.println(httpCode);

        if (httpCode == HTTP_CODE_OK) {
            tft.fillRect(tft.width() - 25, tft.height() - 25, 25, 25, TFT_WHITE);
            tft.fillCircle(tft.width() - 13, tft.height() - 13, 3, TFT_GREEN);

            // Create a new parser instance for each request
            JsonStreamingParser parser;
            parser.setListener(listener);

            WiFiClient& stream = http.getStream();
            while (stream.available()) {
                char c = stream.read();
                parser.parse(c);
            }
        } else {
            tft.fillRect(tft.width() - 25, tft.height() - 25, 25, 25, TFT_RED);
            tft.fillCircle(tft.width() - 13, tft.height() - 13, 3, TFT_GREEN);

            Serial.println("HTTP Error: ");
            Serial.print(httpCode);

        }
        
        http.end();
    } else {
        tft.setTextColor(TFT_RED, TFT_BLACK);
        tft.drawString("WiFi disconnected", 5, tft.height() - 30);
    }

    drawCurrentTime();
    drawBTC();
    Serial.println("============ End of Request ====================");
    delay(UPDATE_INTERVAL); // Wait for 60 seconds before making the next request
}