#include <FS.h>
#include <WiFiManager.h>          //https://github.com/tzapu/WiFiManager WiFi Configuration Magic
#include <SPIFFS.h>
#include <ArduinoJson.h>
#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiUdp.h>
#include <NTPClient.h>
#include <JsonListener.h>
#include <JsonStreamingParser.h>
#include "NotoSansBold15.h"

/* You only need to format SPIFFS the first time you run a
   test or else use the SPIFFS plugin to create a partition
   https://github.com/me-no-dev/arduino-esp32fs-plugin */
#define FORMAT_SPIFFS_IF_FAILED true

#define AA_FONT_SMALL NotoSansBold15

#include <SPI.h>
#include "TFT_eSPI.h"

// Config parameters from the WIFIManager Setup
struct Config {
    String stationId = "8577582";  // Default values
    int limit = 8;
};

// Position of entries on screen
#define POS_TIME 53 //3 
#define POS_DELAY 97 //47 (diff 44)
#define POS_BUS  3 //80 (diff 33)
#define POS_TO   130 //130 (diff 50)
#define POS_INC  18 //18 
#define POS_FIRST 32 //30
// Define the boot button pin - ESP32 built-in button
#define TRIGGER_PIN 0    // GPIO0 is the BOOT button on most ESP32 boards

int bitcoin_price = 0;
bool shouldSaveConfig = false;


// URL Base-Settings
#define getBTCAPI "https://api.coinbase.com/v2/prices/BTC-USD/spot"
String base_url = "http://transport.opendata.ch/v1/stationboard?id=";
String url_limit = "&limit=";
String url = "http://transport.opendata.ch/v1/stationboard?id=8577582&limit=2"; //Fallback

// Loop refresh cycle
unsigned long previousMillis = 0;
const unsigned long UPDATE_INTERVAL = 60000; // Update every 60 seconds

// Define days of the week and months arrays
const char* DAYS[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
const char* MONTHS[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
const long timeOffset = 3600; // UTC+1

// HTTP Settings
const unsigned long HTTP_TIMEOUT = 10000;
const int MAX_RETRIES = 3;
const unsigned long RETRY_DELAY = 1000;


// Create WiFiManager instance
WiFiManager wm;

TFT_eSPI tft = TFT_eSPI();

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", timeOffset);
Config config;

struct Transport {
    String name;
    String number;
    String operatorName;
    String destination;
    String departure;
    String delay;
    String category;
};

class TransportListener: public JsonListener {
private:
    String currentKey;
    String currentPath;
    String station;
    bool inStationboard = false;
    bool inStop = false;


    std::vector<Transport> transports;
    Transport currentTransport;

    void resetTransport() {
        currentTransport.name = "";
        currentTransport.number = "";
        currentTransport.operatorName = "";
        currentTransport.destination = "";
        currentTransport.departure = "";
        currentTransport.delay = "";
        currentTransport.category = "";
    }

    String extractTime(const String& isoTime) {
        if (isoTime.length() >= 16) {
            return isoTime.substring(11, 16); // Extract HH:MM
        }
        return "";
    }

public:
    TransportListener() {}

    const std::vector<Transport>& getTransports() const {
        return transports;
    }

    String getStation() const {
        return station;
    }

    virtual void whitespace(char c) {
        // Ignore whitespace characters
    }

    void startDocument() {   
        //display.fillRect(0,25,display.width(), display.height() - 50, TFT_BLUE);

        // Draw header line
        Serial.println("Start parsing");
        transports.clear();
        inStationboard = false;
        currentPath = "";
        currentKey = "";
        inStop = false;
    }

    void key(String key) {
        currentKey = key;
        
        // Update the path based on where we are
        if (inStationboard) {
            if (inStop) {
                currentPath = "stationboard/stop/" + key;
            } else {
                currentPath = "stationboard/" + key;
            }
        }
        
        //Serial.print("Current path: ");
        //Serial.println(currentPath);
    }

    void value(String value) {
        String fullPath = currentPath + "/" + currentKey;
        // Serial.print("Value at path ");
        // Serial.print(fullPath);
        // Serial.print(": ");
        // Serial.println(value);
        // If required to filter for NULL values, then value == "null"


        if (station.isEmpty()){
            if (fullPath == "/station/name") {
                station = value;
                Serial.print("Found station: ");
                Serial.println(value);
            }
        }

        // Process only the paths we need
        if (fullPath.endsWith("/stop/departure")) {
            currentTransport.departure = extractTime(value);
            // Serial.print("Found departure: ");
            // Serial.println(extractTime(value));
        }
        else if (fullPath.endsWith("/stop/delay")) {
            currentTransport.delay = value;
            // Serial.print("Found delay: ");
            // Serial.println(value);
        }
        else if (fullPath.endsWith("/name")) {
            //Serial.print("Found name: ");
            // Serial.println(value);
            // Serial.println(fullPath + ": " + value);
            currentTransport.name = value;
        }
        else if (fullPath.endsWith("/category")) {
            // Serial.print("Found category: ");
            // Serial.println(value);
            currentTransport.category = value;
        }
        else if (fullPath.endsWith("/number")) {
            // Serial.print("Found number: ");
            // Serial.println(currentTransport.number);
            if (value != "null") {
                // making sure, number stays below 1000, since only 999, like B606 for busses.
                int numValue = value.toInt();
                currentTransport.number = (numValue < 1000) ? String(numValue) : "";
            }
        }
        else if (fullPath.endsWith("/to")) {
            // Serial.print("Found to: ");
            // Serial.println(value);
            if (value.length() > 25) {
                value = value.substring(0, 22) + "...";
            }
            currentTransport.destination = value;
            transports.push_back(currentTransport);
            resetTransport();
        }
    }

    void endArray() {
        // Remove the last path segment
        int lastSlash = currentPath.lastIndexOf('/');
        if (lastSlash >= 0) {
            currentPath = currentPath.substring(0, lastSlash);
        }
        
        // Serial.print("End array, new path: ");
        // Serial.println(currentPath);
    }

    void startArray() {
        if (currentKey.length() > 0) {
            currentPath += "/" + currentKey;
        }
        // Serial.print("Start array at path: ");
        // Serial.println(currentPath);
    }

    void startObject() {
        if (currentKey.length() > 0) {
            currentPath += "/" + currentKey;
        }
        // Serial.print("Start object at path: ");
        // Serial.println(currentPath);
    }

    void endObject() {
        // Remove the last path segment
        int lastSlash = currentPath.lastIndexOf('/');
        if (lastSlash >= 0) {
            currentPath = currentPath.substring(0, lastSlash);
        }
        
        // Serial.print("End object, new path: ");
        // Serial.println(currentPath);
    }

    void endDocument() {
        Serial.println("Ende JSON");
        Serial.println("----------------------------");
    }

private:



};


// Function to get time without seconds
String getTimeWithoutSeconds() {
    String hourStr = String(timeClient.getHours());
    if (hourStr.length() < 2) hourStr = "0" + hourStr;
    
    String minuteStr = String(timeClient.getMinutes());
    if (minuteStr.length() < 2) minuteStr = "0" + minuteStr;
    
    return hourStr + ":" + minuteStr;
}

// Function to get formatted date with time first
String getFormattedDateTime() {
    time_t epochTime = timeClient.getEpochTime();
    struct tm *ptm = gmtime ((time_t *)&epochTime);
    
    String dateTime = getTimeWithoutSeconds();
    dateTime += " - ";
    dateTime += String(ptm->tm_mday);
    dateTime += ". ";
    dateTime += MONTHS[ptm->tm_mon];

    // Add year
    dateTime += " ";
    dateTime += String(ptm->tm_year + 1900);
    
    return dateTime;
}

// Function to get day of week
String getDayOfWeek() {
    return DAYS[timeClient.getDay()];
}

void drawTransport(TFT_eSprite& sprite, const Transport& transport, int yPos) {

    const char* LONG_DISTANCE[] = {"IR", "IC", "EC", "ICE", "ICN", "TGV"};
    const char* REGIONAL[] = {"S", "RE", "RB", "R", "T", "N", "SN"};
    const char* NIGHT[] = {"N", "SN"};
    if (transport.name == "null") return;

    Serial.println("Connection: " + transport.category + transport.number);
    Serial.println("To: " + transport.destination);
    Serial.println("Departure: " + transport.departure);
    Serial.println("Delay: " + transport.departure);
    Serial.println("----------------------------");

    sprite.setTextColor(TFT_WHITE, TFT_BLUE);
    sprite.drawString(transport.departure, POS_TIME, yPos + 1);
    
    if (transport.delay.toInt() > 0) {
        sprite.setTextColor(TFT_YELLOW, TFT_BLUE);
        sprite.drawString("+" + transport.delay, POS_DELAY, yPos + 1);
    }
    
    bool isLongDistance = std::any_of(std::begin(LONG_DISTANCE), std::end(LONG_DISTANCE),
        [&](const char* cat) { return transport.category == cat; });
    bool isRegional = std::any_of(std::begin(REGIONAL), std::end(REGIONAL),
        [&](const char* cat) { return transport.category == cat; });
    bool isNight = std::any_of(std::begin(NIGHT), std::end(NIGHT),
        [&](const char* cat) { return transport.category == cat; });

    if (isLongDistance) {
        sprite.setTextColor(TFT_WHITE, TFT_RED);
        sprite.fillRect(0, yPos, POS_TIME - POS_BUS - 1, POS_INC - 3, TFT_RED);
    } else if (isRegional) {
        sprite.setTextColor(TFT_BLUE, TFT_WHITE);
        sprite.fillRect(0, yPos, POS_TIME - POS_BUS - 1, POS_INC - 3, TFT_WHITE);
    } else if (isNight) {
        sprite.setTextColor(TFT_WHITE, TFT_BLACK);
        sprite.fillRect(0, yPos, POS_TIME - POS_BUS - 1, POS_INC - 3, TFT_BLACK);
    } else {
        sprite.setTextColor(TFT_WHITE, TFT_BLUE);
    }

    sprite.drawString(transport.category + transport.number, POS_BUS, yPos + 1);
    sprite.setTextColor(TFT_WHITE, TFT_BLUE);
    sprite.drawString(transport.destination, POS_TO, yPos + 1);
}


void displayTransports(const std::vector<Transport>& transports) {
    TFT_eSprite sprite(&tft);
    sprite.createSprite(tft.width(), 5 * POS_INC);
    sprite.loadFont(AA_FONT_SMALL);

    // Draw first half (0-4)
    sprite.fillSprite(TFT_BLUE);
    for (size_t i = 0; i < std::min(size_t(5), transports.size()); i++) {
        
        drawTransport(sprite, transports[i], i * POS_INC);
    }
    sprite.pushSprite(0, POS_FIRST);

    // Draw second half (5-9)
    sprite.fillSprite(TFT_BLUE);
    for (size_t i = 5; i < transports.size(); i++) {
        drawTransport(sprite, transports[i], (i-5) * POS_INC);
    }
    sprite.pushSprite(0, POS_FIRST + (5 * POS_INC));

    //sprite.deleteSprite();
}


 void displayStatus(bool isSuccess) {
    // Clear the status area with white background
    tft.fillRect(tft.width() - 25, tft.height() - 25, 25, 25, TFT_WHITE);
    
    // Draw the circle in green or red based on status
    tft.fillCircle(tft.width() - 13, tft.height() - 13, 3, 
                   isSuccess ? TFT_GREEN : TFT_RED);
}

// JsonStreamingParser parser;
TransportListener listener;

void drawStation(const String& station) {
    tft.loadFont(AA_FONT_SMALL);
    tft.setTextColor(TFT_BLACK, TFT_WHITE);
    tft.fillRect(0, 0, tft.width(), 25, TFT_WHITE);
    tft.drawString(station, POS_BUS, 7);
}

void drawCurrentTime() {
    timeClient.update();
    
    // Create temporary sprite for time display
    TFT_eSprite timeSprite(&tft);
    timeSprite.createSprite(tft.width() / 2, 25);
    timeSprite.loadFont(AA_FONT_SMALL);
    
    // Clear sprite and set background
    timeSprite.fillSprite(TFT_WHITE);
    
    
    // Draw time and date
    timeSprite.setTextColor(TFT_BLACK, TFT_WHITE);
    timeSprite.drawString(getFormattedDateTime(), 4, 5);
    
    // Push to bottom of screen
    timeSprite.pushSprite(0, tft.height() - 25);
    
    // Clean up
    // timeSprite.deleteSprite();
}

void drawBTC() {
    HTTPClient http;
    http.setConnectTimeout(HTTP_TIMEOUT);
    http.setTimeout(HTTP_TIMEOUT);
    http.begin(getBTCAPI);
    
    int httpCode = http.GET();
    Serial.print("HTTPCODE: ");
    Serial.println(httpCode);

    String bitcoin_price = "";
    
    if (httpCode == HTTP_CODE_OK) {

        String payload = http.getString();
        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, payload);
        
        if (doc.containsKey("data") && doc["data"].containsKey("amount")) {
            bitcoin_price = doc["data"]["amount"].as<String>().toInt();
        }
        displayStatus(true);
    } else {
        displayStatus(false);
    }
    
    http.end();

    // Create temporary sprite for BTC price display
    TFT_eSprite btcSprite(&tft);
    btcSprite.createSprite((tft.width() / 2) - 25, 25);
    btcSprite.loadFont(AA_FONT_SMALL);
    
    // Clear sprite and set background
    btcSprite.fillSprite(TFT_WHITE);
    
    // Draw BTC price
    btcSprite.setTextDatum(TR_DATUM);
    btcSprite.setTextColor(TFT_BLACK, TFT_WHITE);
    btcSprite.drawString("BTC $" + bitcoin_price, btcSprite.width(), 5);
    
    // Push to bottom-right of screen
    btcSprite.pushSprite(tft.width() / 2, tft.height() - 25);
    
    Serial.print("Bitcoin Price: ");
    Serial.println(bitcoin_price);
    
    // Clean up
    // btcSprite.deleteSprite();
}

void drawStationboard() {
    static TransportListener listener;
    HTTPClient http;
    http.setConnectTimeout(HTTP_TIMEOUT);
    
    String url = "http://transport.opendata.ch/v1/stationboard?id=" + 
                 config.stationId + "&limit=" + String(config.limit);
    http.begin(url);
    
    if (http.GET() == HTTP_CODE_OK) {
        String response = http.getString();
        // Handle Unicode characters
        response.replace("\\u00fc", "ü");
        response.replace("\\u00f6", "ö");
        response.replace("\\u00e4", "ä");
        response.replace("\\u00dc", "Ü");
        response.replace("\\u00d6", "Ö");
        response.replace("\\u00c4", "Ä");
        
        JsonStreamingParser parser;
        parser.setListener(&listener);
        for (char c : response) {
            parser.parse(c);
        }
        
        drawStation(listener.getStation());
        displayTransports(listener.getTransports());
    }
    http.end();
}

void checkForConfigReset() {
    // Initialize trigger pin as input with pullup
    pinMode(TRIGGER_PIN, INPUT_PULLUP);
    
    // Allow the device to boot properly
    delay(1000);
    
    // Display instruction
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawString("Press BOOT to reset WiFi", 20, 80);
    tft.drawString("Waiting 5 seconds...", 20, 100);
    
    // Check for button press after boot
    unsigned long startTime = millis();
    while (millis() - startTime < 5000) {  // Wait 5 seconds for button press
        if (digitalRead(TRIGGER_PIN) == LOW) {
            delay(50);  // Simple debounce
            if (digitalRead(TRIGGER_PIN) == LOW) {  // Double check
                Serial.println("Reset button pressed - clearing WiFi settings");
                
                tft.fillScreen(TFT_BLACK);
                tft.drawString("Clearing settings...", 20, 60);
                
                // Create WiFiManager instance
                WiFiManager wm;
                
                // Reset settings
                wm.resetSettings();
                // Then try to mount and clear SPIFFS if possible
                if (SPIFFS.begin(true)) {  // Mount SPIFFS with formatting on failure
                    if (SPIFFS.exists("/config.json")) {
                        SPIFFS.remove("/config.json");
                        Serial.println("Config found and deleted");
                    }
                    SPIFFS.end();  // Clean unmount
                }
                tft.drawString("Settings cleared!", 20, 80);
                tft.drawString("Restart manually", 20, 100);
                tft.drawString("To config your Stationboard:", 20, 120);
                tft.drawString("Connect to access point TransportDisplay_AP", 20, 140);
                delay(2000);
                
                ESP.restart();
            }
        }
        delay(10);
    }
}

void saveConfigCallback () {
    Serial.println("Should save config");
    shouldSaveConfig = true;
}

void loadConfiguration() {
    if (SPIFFS.exists("/config.json")) {
        File configFile = SPIFFS.open("/config.json", FILE_READ);
        if (configFile) {
            DynamicJsonDocument doc(1024);
            DeserializationError error = deserializeJson(doc, configFile);
            
            if (!error) {
                config.stationId = doc["station_id"].as<String>();
                config.limit = doc["limit"].as<int>();
            }
            configFile.close();
        } else {
            Serial.println("No config found");
        }
    }
}

void saveConfiguration() {
    DynamicJsonDocument doc(1024);
    doc["station_id"] = config.stationId;
    doc["limit"] = config.limit;

    File configFile = SPIFFS.open("/config.json", FILE_WRITE);
    if (!configFile) {
        Serial.println("- failed to open file for writing");
        return;
    }

#if defined(ARDUINOJSON_VERSION_MAJOR) && ARDUINOJSON_VERSION_MAJOR >= 6
    serializeJson(doc, Serial);
    serializeJson(doc, configFile);
#else
    json.printTo(Serial);
    json.printTo(configFile);
#endif
    configFile.close();
    
    // Verify the write
    configFile = SPIFFS.open("/config.json");
    if (!configFile) {
        Serial.println("- failed to open file for verification");
        return;
    }
    
    if (configFile.size() > 0) {
        Serial.println("- config file verified");
        Serial.println("Contents:");
        while(configFile.available()) {
            Serial.write(configFile.read());
        }
    } else {
        Serial.println("- config file appears empty");
    }
    configFile.close();
}


void setupWiFiManager() {
    // Check for reset trigger first
    Serial.println("Entering reset routine");
    checkForConfigReset();

    // Load existing configuration
    Serial.println("Trying to load config from file");
    loadConfiguration();

    // Set config save notify callback
    wm.setSaveConfigCallback(saveConfigCallback);

    // Add custom parameters for transport display settings
    WiFiManagerParameter custom_station_id("station", "Station ID", String(config.stationId).c_str(), 150);
    WiFiManagerParameter custom_limit("limit", "Number of Entries", String(config.limit).c_str(), 2);
    
    wm.addParameter(&custom_station_id);
    wm.addParameter(&custom_limit);

    // Customize the configuration portal
    wm.setTitle("Transport Display Setup");
    
    // Enable debug output
    wm.setDebugOutput(true);
    
    // Set dark theme
    wm.setClass("invert");

    // Set configuration portal timeout (optional, in seconds)
    wm.setConfigPortalTimeout(600);

    // Start the configuration portal
    if (!wm.autoConnect("TransportDisplay_AP")) {
        tft.drawString("To config your Stationboard:", 10, 110);
        tft.drawString("Connect to access point TransportDisplay_AP", 10, 130);
        Serial.println("Failed to connect and hit timeout");

        delay(3000);
        ESP.restart();
        delay(5000);
    } else {
        // If you get here you have connected to the WiFi
        tft.drawString("Successfully connected to WiFi network!", 20, 100);
        Serial.println("Successfully connected to WiFi network!");
    }

    
    // Read updated parameters
    config.stationId = custom_station_id.getValue();
    config.limit = String(custom_limit.getValue()).toInt();

    // Save the custom parameters to config
    if (shouldSaveConfig) {
        saveConfiguration();
    }
}


void setup() {
    Serial.begin(115200);

    if (SPIFFS.begin(true)) {
        Serial.println("SPIFFS Mounted");
    }

    // Initialize display
    tft.init();
    tft.setRotation(1);
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE);

    // reset settings - wipe stored credentials for testing
    // these are stored by the esp library
    // wm.resetSettings();

    // Call WiFiManager setup
    setupWiFiManager();
    
    // URL Konstruktor
    url = base_url + config.stationId + url_limit + config.limit;
    Serial.println();
    Serial.print("URL: ");
    Serial.println(url);
        
    // Initialize time client
    timeClient.begin();
    timeClient.setTimeOffset(timeOffset); // UTC+1

    // Initial Scren Setup
    tft.fillScreen(TFT_BLUE);
    tft.fillRect(0, 0 , tft.width(), 25, TFT_WHITE); //header
    tft.fillRect(0, tft.height() - 25 , tft.width(), 25, TFT_WHITE); //footer
    tft.loadFont(AA_FONT_SMALL);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.drawString("Loading .",POS_BUS, POS_FIRST);
    delay(100);
    tft.drawString("Loading ..",POS_BUS, POS_FIRST);
    delay(100);
    tft.drawString("Loading ...",POS_BUS, POS_FIRST);

    // Initial data fetch
    if (WiFi.status() == WL_CONNECTED) {
        drawCurrentTime();
        drawStationboard();
        drawBTC();
    }

}


void loop() {
    unsigned long currentMillis = millis();
    
    if (currentMillis - previousMillis >= UPDATE_INTERVAL) {
        previousMillis = currentMillis;
        
        if (WiFi.status() == WL_CONNECTED) {
            drawCurrentTime();
            drawStationboard();
            drawBTC();
        } else {
            tft.setTextColor(TFT_RED, TFT_BLUE);
            tft.drawString("WiFi disconnected", POS_BUS, POS_FIRST);
            Serial.println("Wifi disconnected");
            WiFi.reconnect();
        }

        // Debug info (no WiFi needed)
        Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
        Serial.printf("Largest block: %d bytes\n", ESP.getMaxAllocHeap());
        UBaseType_t watermark = uxTaskGetStackHighWaterMark(NULL);
        Serial.printf("Stack watermark: %d bytes\n", watermark);
        Serial.println("============ End of refresh cycle ==================");
    }
}
